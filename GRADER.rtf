{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf340
{\fonttbl\f0\fmodern\fcharset0 Courier;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww17620\viewh8400\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs26 \cf0 Write a file called GRADER that briefly documents your data structures and the\
design decisions you made in WUGraph.java and Kruskal.java that extend or\
depart from those discussed here.  In particular, tell us what choices you made\
in your implementation to ensure that removeVertex() runs in O(d) time (as\
described in Part I, design element [4]) and getVertices() runs in O(|V|) time\
(design element [2]).\
\
\
Note: Each method I wrote has a Logic section that entails what I thought behind it. I used 3 different "entities" to help ensure that I was able to meet all the speed requirements.\
\
HashTable for Vertex\
HashTable for Edge\
Vertex DList\
\
DataStructures Used\
HashTableChained\
Entry\
VertexPair\
DList\
DListNode\
List\
ListNode\
Dictionary\
Neighbors\
WUGraph\
\
\pard\tx529\pardeftab529\pardirnatural

\f1\fs22 \cf0 \CocoaLigature0 The HashTable for vertecies will have the vertex as both the keys and values\
    key will be the vertex\
    value will be the vertex DListNode in the Vertex list\
The Vertex List will have VertexPairs as objects\
    Object1 will be the vertex value\
    Object2 will be a DList that will contain edges\
The DLists that contain edges will have a Vertexpair Object as well\
    Object 1 will be a vertex Pair\
        Object 1-1 will be a vertexPair\
            Object 1-1-1 will be the first vertex of the edge (Origin, will always be the vertex we are currently at)\
            Object 1-1-2 will be the second vertex of the edge (Destination)\
        Object 1-2 will be the weight\
    Object 2 will be the "partner of the current node". it will be the correspoinding DListNode\
The Hashtable for the edges will have the two edges as the key, the value will be a DListNode\
    key: VertexPair with 2 vertecies\
    value: DListNode of the Edge\
\
removeVertex()\
use hashTable to access Vertex, constant time\
walk through adjacency list of Vertex, each of these edges has a "partner" which is in the destination vertex's adjacency list, use this to remove all of the edges in others adjacency list. O(d)\
remove the vertex O(1)\
\
getVertices()\
Walk down the whole DList and put each item into the array. This will take O(v) time since you just walk through all vertices}